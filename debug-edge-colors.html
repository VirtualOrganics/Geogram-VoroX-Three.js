<!DOCTYPE html>
<html>
<head>
    <title>Debug Edge Colors</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .edge { padding: 5px; margin: 2px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Edge Color Debug</h1>
    <button onclick="testEdgeScoring()">Test Edge Scoring</button>
    <div id="output"></div>
    
    <script type="module">
        import { createVoroX } from './src/js/VoroXAdapter.js';
        import { calculateEdgeScores } from './src/js/vorox2/dynamics.js';
        
        window.testEdgeScoring = async function() {
            const output = document.getElementById('output');
            output.innerHTML = 'Loading...';
            
            // Load module
            if (!window.Module) {
                const script = document.createElement('script');
                script.src = './dist/periodic_delaunay.js';
                document.head.appendChild(script);
                await new Promise(resolve => script.onload = resolve);
                window.Module = await window.PeriodicDelaunayModule();
            }
            
            // Create simple test points
            const points = [];
            for (let i = 0; i < 20; i++) {
                points.push([Math.random(), Math.random(), Math.random()]);
            }
            
            // Create VoroX (using correct API)
            const vorox = await createVoroX({ 
                Module: window.Module, 
                points: points, 
                periodic: true,
                centering: 'circumcenter'
            });
            const foam = vorox.getFoam();
            
            console.log('Foam:', foam);
            
            // Calculate edge scores
            const result = calculateEdgeScores(foam, 10, 0.85);
            console.log('Edge result:', result);
            
            const scores = result.scores;
            const graph = result.graph;
            
            // Display results
            let html = '<h2>Results</h2>';
            html += `<p>Total edges: ${foam.voronoiEdges.length}</p>`;
            html += `<p>Graph nodes: ${graph.nodes.length}</p>`;
            html += `<p>Graph links: ${graph.links.length}</p>`;
            html += `<p>Scores computed: ${scores.size}</p>`;
            
            // Get score statistics
            const scoreValues = Array.from(scores.values());
            const min = Math.min(...scoreValues);
            const max = Math.max(...scoreValues);
            const avg = scoreValues.reduce((a,b) => a+b, 0) / scoreValues.length;
            
            html += `<h3>Score Statistics</h3>`;
            html += `<p>Min: ${min.toFixed(6)}</p>`;
            html += `<p>Max: ${max.toFixed(6)}</p>`;
            html += `<p>Avg: ${avg.toFixed(6)}</p>`;
            html += `<p>Range: ${(max-min).toFixed(6)}</p>`;
            
            // Show individual edges with colors
            html += '<h3>Edge Colors</h3>';
            const sortedScores = Array.from(scores.entries()).sort((a,b) => b[1] - a[1]);
            
            for (const [key, score] of sortedScores.slice(0, 20)) {
                // Compute color like in the main app
                const t = Math.max(0, Math.min(1, score));
                const hue = t * 120; // 0=red, 120=green in degrees
                const color = `hsl(${hue}, 90%, 50%)`;
                
                html += `<div class="edge" style="background-color: ${color}">`;
                html += `${key}: score=${score.toFixed(6)} (t=${t.toFixed(3)}, hue=${hue.toFixed(0)}°)`;
                html += `</div>`;
            }
            
            // Check for issues
            html += '<h3>Diagnostics</h3>';
            if (scoreValues.every(v => Math.abs(v - scoreValues[0]) < 0.0001)) {
                html += '<p style="color:red">⚠️ All scores are nearly identical!</p>';
                html += '<p>This means the PageRank is not differentiating between edges.</p>';
                html += '<p>Possible causes:</p>';
                html += '<ul>';
                html += '<li>All edges have similar connectivity (uniform mesh)</li>';
                html += '<li>Not enough iterations</li>';
                html += '<li>Graph is too regular</li>';
                html += '</ul>';
            } else {
                html += '<p style="color:green">✓ Scores show variation</p>';
            }
            
            // Check graph connectivity
            const avgLinks = graph.links.length / graph.nodes.length;
            html += `<p>Average links per node: ${avgLinks.toFixed(2)}</p>`;
            if (avgLinks < 1) {
                html += '<p style="color:orange">⚠️ Low connectivity - many isolated edges</p>';
            }
            
            output.innerHTML = html;
        }
    </script>
</body>
</html>
