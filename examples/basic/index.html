<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 380px;
        }
        #controls-content { max-height: calc(100vh - 40px); overflow-y: auto; }
        .control-group {
            margin: 10px 0;
        }
        .section-header { font-weight: bold; margin: 12px 0 6px 0; padding: 6px 8px; background: #f2f2f2; border-radius: 4px; }
        #controls-toggle { background: #007bff; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-bottom: 8px; }
        #controls.hidden { width: auto; padding: 8px 10px; }
        #controls.hidden #controls-content { display: none; }
        .row-2 { display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; align-items: center; }
        .row-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; align-items: center; }
        .row-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; align-items: center; }
        .sub-label { font-size: 12px; text-align: center; opacity: 0.85; }
        .inline-pair { display: flex; align-items: center; gap: 8px; }
        .inline-tight { gap: 4px; }
        label {
            display: inline-block;
            width: 100px;
            font-size: 14px;
            white-space: nowrap;
        }
        input[type="number"] {
            width: 80px;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
        <div class="section-header">Voro-X / Geogram</div>
        <div class="control-group row-2">
            <div class="inline-pair"><label>Points:</label><input type="number" id="numPoints" value="150" min="4" max="5000"></div>
            <div class="inline-pair inline-tight"><label>Min Dist:</label><input style="margin-left:-6px" type="number" id="minDistance" value="0.05" min="0.001" max="0.3" step="0.001"></div>
        </div>
        <div class="control-group">
            <label>Voronoi Method:</label>
            <select id="voronoiMethod">
                <option value="barycenter" selected>Barycenter</option>
                <option value="circumcenter">Circumcenter</option>
            </select>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Periodic</div>
            <div class="sub-label">Ghost Cells</div>
            <div class="sub-label">MIC</div>
            <div style="text-align:center"><input type="checkbox" id="periodicMode"></div>
            <div style="text-align:center"><input type="checkbox" id="showGhostCells"></div>
            <div style="text-align:center"><input type="checkbox" id="useMIC"></div>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Background</div>
            <div class="sub-label">Boundary</div>
            <div class="sub-label">Poisson</div>
            <div style="text-align:center"><input type="color" id="backgroundColor" value="#f0f0f0"></div>
            <div style="text-align:center"><input type="checkbox" id="showBoundary" checked></div>
            <div style="text-align:center"><input type="checkbox" id="poissonSampling" checked></div>
        </div>
        <hr>
        <div class="section-header">Delaunay Triangles / Tetrahedra</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Delaunay</div>
            <div class="sub-label">Tetrahedra</div>
            <div style="text-align:center"><input type="checkbox" id="showVertices" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showDelaunay" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showTetrahedra" checked></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="delaunaySize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="vertexColor" value="#000000">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="10" step="1" disabled>
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="delaunayEdgeColor" value="#808080">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Tetra Color:</label>
                <input type="color" id="tetraColor" value="#D3D3D3">
            </div>
            <div>
                <label>Opacity:</label>
                <input type="number" id="tetraOpacity" value="0.01" min="0.0" max="1.0" step="0.01">
            </div>
        </div>
        <hr>
        <div class="section-header">Voronoi Diagrams</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Edges</div>
            <div class="sub-label">Faces</div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoi"></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiEdgesToggle"></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiFaces"></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="voronoiSize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="voronoiVertexColor" value="#0000FF">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="voronoiEdgeWidth" value="2" min="1" max="10" step="1" disabled>
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="voronoiEdgeColor" value="#4169E1">
            </div>
        </div>
        <!-- Move Tetra controls to Delaunay section and place Voronoi Method later -->
        <div class="control-group">
            <div class="row-2">
                <div>
                    <label>Faces Color:</label>
                    <input type="color" id="voronoiFaceColor" value="#ADD8E6">
                </div>
                <div>
                    <label>Opacity:</label>
                    <input type="number" id="voronoiFaceOpacity" value="0.04" min="0.0" max="1.0" step="0.01">
                </div>
            </div>
        </div>
        <div class="control-group">
            <label>Voronoi Method:</label>
            <select id="voronoiMethod">
                <option value="barycenter" selected>Barycenter</option>
                <option value="circumcenter">Circumcenter</option>
            </select>
        </div>
        <hr>
        <div class="section-header">Flow Dynamics</div>
        <div class="control-group">
            <div class="row-2">
                <div class="inline-pair"><input type="checkbox" id="showVoroX"><label>Flow</label></div>
                <div class="inline-pair"><label>Max Segs:</label><input type="number" id="voroxMaxSegs" value="2000" min="100" max="20000" step="100"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="row-2">
                <div class="inline-pair"><input type="checkbox" id="showVoroXKnots" checked><label>Knots</label></div>
                <div class="inline-pair"><label>Size:</label><input type="number" id="voroxKnotWidth" value="2.5" min="1" max="10" step="0.5"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="row-2">
                <div class="inline-pair"><input type="checkbox" id="animateVoroXFlow"><label>Animate</label></div>
                <div class="inline-pair"><label>Speed:</label><input type="number" id="voroxFlowSpeed" value="0.6" min="0.1" max="5" step="0.1"></div>
            </div>
        </div>
        <div class="control-group" style="margin-top:8px">
            <div class="inline-pair"><input type="checkbox" id="voroxColorByKnot" checked><label for="voroxColorByKnot">Color by Knot</label></div>
        </div>
        <hr>
        <button id="regenerate">Generate New Points</button>
        <button id="recompute">Recompute Triangulation</button>
        <div id="status" class="status"></div>
        <div id="stats" style="font-size:12px; margin-top:8px">
            <span id="statsCore">Loading...</span><br>
            <span id="statsPerf"></span>
        </div>
        </div>
    </div>
    
    <script src="../../dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { DelaunayComputation } from '../../src/js/DelaunayComputation.js';
        import { buildVoroXFlow } from '../../src/js/VoroXDynamics.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiGroup, tetrahedraGroup, boundaryGroup, voronoiFacesGroup, ghostCellsGroup;
        let voroxGroup, voroxTracerGroup;
        let Module;
        let currentPoints = [];
        let computation = null;
        let voroxFlowCache = null; // cached flow from last draw
        let voroxCenters = null;   // cached centers
        let voroxTracers = [];     // active tracer particles
        let lastFrameTime = performance.now();
        let lastFPSUpdate = performance.now();
        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xc2c2c2);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            voroxGroup = new THREE.Group();
            voroxTracerGroup = new THREE.Group();
            
            scene.add(verticesGroup);
            scene.add(delaunayGroup);
            scene.add(voronoiGroup);
            scene.add(tetrahedraGroup);
            scene.add(boundaryGroup);
            scene.add(voronoiFacesGroup);
            scene.add(ghostCellsGroup);
            scene.add(voroxGroup);
            scene.add(voroxTracerGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers (toggle with boundary)
            const axesHelper = new THREE.AxesHelper(0.2);
            axesHelper.name = 'axesHelper';
            scene.add(axesHelper);
            // Refresh ghost cell tiling if toggled
            createGhostCellTiling();
        }

        // Ghost cells tiling (26 neighbors) using MIC-thin edges
        function createGhostCellTiling() {
            // Cleanup previous
            ghostCellsGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                }
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            ghostCellsGroup.clear();

            if (!computation) return;
            if (!document.getElementById('showGhostCells').checked) return;

            // Colors
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);

            const ghostDelaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt, opacity: 0.3, transparent: true });
            const ghostVoronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, opacity: 0.2, transparent: true });

            // Build base geometries (thin line segments) using MIC
            const buildDelaunayGeometry = () => {
                const positions = [];
                const edgeSet = new Set();
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (edgeSet.has(key)) continue;
                        edgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        positions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                    }
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };

            const buildVoronoiGeometry = () => {
                const positions = [];
                for (const edge of computation.voronoiEdges) {
                    const p1 = edge.start;
                    const p2 = computation.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                    positions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };

            const delaunayGeometry = buildDelaunayGeometry();
            const voronoiGeometry = buildVoronoiGeometry();

            // Offsets of 26 neighbor cells
            const offsets = [];
            for (let x=-1; x<=1; x++) for (let y=-1; y<=1; y++) for (let z=-1; z<=1; z++) {
                if (x===0 && y===0 && z===0) continue;
                offsets.push([x,y,z]);
            }

            for (const [ox,oy,oz] of offsets) {
                const g = new THREE.Group();
                g.position.set(ox,oy,oz);
                if (delaunayGeometry && document.getElementById('showDelaunay').checked) {
                    g.add(new THREE.LineSegments(delaunayGeometry.clone(), ghostDelaunayMaterial));
                }
                if (voronoiGeometry && document.getElementById('showVoronoi').checked) {
                    g.add(new THREE.LineSegments(voronoiGeometry.clone(), ghostVoronoiMaterial));
                }
                ghostCellsGroup.add(g);
            }
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }
        
        // Visualize vertices
        function drawVertices(computation) {
            verticesGroup.clear();
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            
            const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: vertexColorInt });
            
            for (const point of computation.pointsArray) {
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(point[0], point[1], point[2]);
                verticesGroup.add(sphere);
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(computation) {
            delaunayGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const edgeSet = new Set();
            const material = new THREE.LineBasicMaterial({ color: 0x0066ff });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0099ff, 
                linewidth: 2 
            });
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]],
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        
                        // Get vertex positions
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        // Check if edge crosses periodic boundary
                        const isPeriodic = computation._isPeriodicEdge(p1, p2);
                        
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            p1[0], p1[1], p1[2],
                            p2[0], p2[1], p2[2]
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const line = new THREE.Line(
                            geometry, 
                            isPeriodic ? periodicMaterial : material
                        );
                        delaunayGroup.add(line);
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            const voronoiColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiColorInt = parseInt(voronoiColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt,
                linewidth: 2 
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt, 
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiColorInt,
                emissive: voronoiColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.clear();
            
            // Support faces for both barycenter and circumcenter methods; limit point count for perf
            const maxPointsForFaces = 300;
            const showFaces = document.getElementById('showVoronoiFaces').checked;
            voronoiFacesGroup.visible = showFaces;
            if (!showFaces) return;
            if (computation.numPoints > maxPointsForFaces) {
                console.log(`Skipping faces: points=${computation.numPoints} > ${maxPointsForFaces}`);
                return;
            }
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the centers (barycenters==circumcenters in this mode)
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const center = computation.barycenters[index];
                if (!center) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...center));
                });
            });

            // For each cell, compute the convex hull of its vertices (centers)
            let built = 0;
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return; // Need at least 4 points for a 3D shape

                // Create a convex geometry from the vertices of the Voronoi cell
                // Apply MIC to bring all vertices to the same periodic image as the first vertex
                const ref = cellVertices[0];
                const adjusted = cellVertices.map(v => {
                    const out = v.clone();
                    if (!computation.isPeriodic) return out;
                    for (let k = 0; k < 3; k++) {
                        let diff = v.getComponent(k) - ref.getComponent(k);
                        if (diff > 0.5) out.setComponent(k, v.getComponent(k) - 1.0);
                        else if (diff < -0.5) out.setComponent(k, v.getComponent(k) + 1.0);
                    }
                    return out;
                });

                const geometry = new ConvexGeometry(adjusted);
                const mesh = new THREE.Mesh(geometry, material);
                voronoiFacesGroup.add(mesh);
                built++;
            });
            console.log(`Built ${built} Voronoi cell meshes`);
        }
        
        // Unified mesh drawing function that properly handles periodic edges
        function drawMeshes(computation) {
            delaunayGroup.clear();
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();

            console.log(`Drawing meshes for ${computation.isPeriodic ? 'PERIODIC' : 'NON-PERIODIC'} mode`);

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt, linewidth: 2, opacity: 0.6, transparent: true });

            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges ---
            const useMIC = document.getElementById('useMIC').checked;
            const delaunayEdgeSet = new Set();
            const thickDelaunayWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
            const thickVoronoiWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
            if (useMIC) {
                // Thick edges using MIC
                const delaunayGeom = new LineGeometry();
                const delaunayPositions = [];
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        delaunayPositions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                    }
                }
                delaunayGeom.setPositions(delaunayPositions);
                const delaunayMat = new LineMaterial({ color: delaunayEdgeColorInt, linewidth: thickDelaunayWidth, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
                const delaunayLine = new Line2(delaunayGeom, delaunayMat);
                delaunayLine.computeLineDistances();
                delaunayGroup.add(delaunayLine);
            } else {
                // Thin edges (existing path with MIC per-edge)
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                        delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                    }
                }
            }

            console.log(`Drew ${periodicEdgeCount} periodic edges out of ${delaunayEdgeSet.size} total Delaunay edges`);
            
            // --- Draw Voronoi Edges ---
            if (useMIC) {
                const vorGeom = new LineGeometry();
                const positions = [];
                for (const edge of computation.voronoiEdges) {
                    const p1 = edge.start;
                    const p2 = computation.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                    positions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                }
                vorGeom.setPositions(positions);
                const vorMat = new LineMaterial({ color: voronoiEdgeColorInt, linewidth: thickVoronoiWidth, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
                const vorLine = new Line2(vorGeom, vorMat);
                vorLine.computeLineDistances();
                voronoiGroup.add(vorLine);
            } else {
                for (const edge of computation.voronoiEdges) {
                    const p1 = edge.start;
                    const p2 = computation.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                    voronoiGroup.add(new THREE.Line(lineGeom, computation.isPeriodic ? voronoiPeriodicMaterial : voronoiMaterial));
                }
            }
            
            // Draw Voronoi vertices (barycenters or circumcenters)
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }

            // Draw VoroX flow if enabled
            if (document.getElementById('showVoroX').checked) {
                const centers = computation.barycenters;
                const faceAdj = computation.getFaceAdjacency();
                const flow = buildVoroXFlow({ tetrahedra: computation.tetrahedra, centers, faceAdjacency: faceAdj });
                const colorByKnot = document.getElementById('voroxColorByKnot').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                voroxFlowCache = flow;
                voroxCenters = centers;

                let drawn = 0;
                for (let ti = 0; ti < flow.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = flow.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = centers[ti];
                        let c2 = centers[nxt.tet];
                        if (computation.isPeriodic) {
                            c2 = getMinimumImage(c1, c2);
                        }
                        const col = colorByKnot && flow.facetToKnot[ti][fi] > 0
                            ? new THREE.Color().setHSL((flow.facetToKnot[ti][fi] * 0.1375) % 1, 0.85, 0.5)
                            : new THREE.Color(0xff00aa);
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.9, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                        ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Highlight knots (cycles) if enabled
                if (document.getElementById('showVoroXKnots').checked && flow.knots.length) {
                    const baseWidth = parseFloat(document.getElementById('voroxKnotWidth').value);
                    for (const knot of flow.knots) {
                        for (let i = 0; i < knot.length; i++) {
                            const a = knot[i];
                            const b = flow.activeEdges[a.tet][a.face];
                            if (!b) continue;
                            let c1 = centers[a.tet];
                            let c2 = centers[b.tet];
                            if (computation.isPeriodic) {
                                c2 = getMinimumImage(c1, c2);
                            }
                            const mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: baseWidth, opacity: 1.0 });
                            const g = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                            ]);
                            voroxGroup.add(new THREE.Line(g, mat));
                        }
                    }
                }
                // Initialize tracers if animation is on
                if (document.getElementById('animateVoroXFlow').checked) {
                    initVoroxTracers(flow, centers);
                } else {
                    clearVoroxTracers();
                }
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                const vertices = tet.map(i => computation.pointsArray[i]);
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // Compute Delaunay-Voronoi
        async function computeDelaunayVoronoi() {
            if (!Module) return;
            
            // Diagnostic check for corrupt input data
            console.log("--- New Computation Triggered ---");
            console.log(`Checking ${currentPoints.length} points before sending to WASM.`);
            let outliersFound = 0;
            for (const p of currentPoints) {
                if (!p || p.length !== 3 || p[0] < 0 || p[0] > 1 || p[1] < 0 || p[1] > 1 || p[2] < 0 || p[2] > 1) {
                    console.error("🔴 OUTLIER DETECTED! This point is outside the [0, 1] unit cube and will corrupt the periodic triangulation:", p);
                    outliersFound++;
                }
            }
            if (outliersFound > 0) {
                console.error(`Found ${outliersFound} outlier points. Halting computation.`);
                setStatus(`Error: Found ${outliersFound} outlier points.`, false);
                return; // Stop execution if data is bad
            }
            console.log("✅ Point data is clean. Proceeding with computation...");
            
            const isPeriodic = document.getElementById('periodicMode').checked;
            
            setStatus('Computing...', false);
            
            try {
                // Create computation instance
            const method = document.getElementById('voronoiMethod').value;
            computation = new DelaunayComputation(currentPoints, isPeriodic, method);
                
                // Run the computation
                await computation.compute(Module);
                
                // Get statistics
                const stats = computation.getStats();
                setStatus(`Success! ${stats.numTetrahedra} tetrahedra, ${stats.numVoronoiEdges} Voronoi edges`, true);
                
            // Update visualization
                drawVertices(computation);
                drawMeshes(computation);
                drawTetrahedra(computation);
            // Ensure faces draw if toggle is on
            drawVoronoiFaces(computation);
                
                updateStats();
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, false);
                console.error(error);
            }
        }
        
        // Update statistics
        function updateStats() {
            if (!computation) return;
            
            const stats = computation.getStats();
            const fps = (1000 / (performance.now() - lastFrameTime)).toFixed(0);
            document.getElementById('statsCore').textContent = `Mode: ${stats.isPeriodic ? 'Periodic' : 'Non-periodic'} | Vertices: ${stats.numPoints} | Tetrahedra: ${stats.numTetrahedra} | Voronoi Edges: ${stats.numVoronoiEdges}`;
            document.getElementById('statsPerf').textContent = `FPS: ${fps}`;
        }
        
        // Set status message
        function setStatus(message, isSuccess) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateVoroxTracers();
            renderer.render(scene, camera);
            const now = performance.now();
            if (now - lastFPSUpdate > 500) {
                const fps = (1000 / (now - lastFrameTime)).toFixed(0);
                const perfEl = document.getElementById('statsPerf');
                if (perfEl) perfEl.textContent = `FPS: ${fps}`;
                lastFPSUpdate = now;
            }
            lastFrameTime = now;
        }

        // --- VoroX flow animation helpers ---
        function clearVoroxTracers() {
            voroxTracerGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voroxTracerGroup.clear();
            voroxTracers = [];
        }

        function initVoroxTracers(flow, centers) {
            clearVoroxTracers();
            // Seed a small set of tracers from random facets
            const numTracers = Math.min(200, centers.length * 2);
            for (let i = 0; i < numTracers; i++) {
                const tet = Math.floor(Math.random() * flow.activeEdges.length);
                const face = Math.floor(Math.random() * 4);
                const next = flow.activeEdges[tet][face];
                if (!next) continue;
                const start = new THREE.Vector3(...centers[tet]);
                const end = new THREE.Vector3(...centers[next.tet]);
                const dir = new THREE.Vector3().subVectors(end, start);
                const geom = new THREE.SphereGeometry(0.003, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.copy(start);
                voroxTracerGroup.add(mesh);
                voroxTracers.push({ mesh, curTet: tet, curFace: face, t: 0, dir, start, end });
            }
        }

        function stepTracer(tr, dt) {
            const speed = parseFloat(document.getElementById('voroxFlowSpeed').value);
            tr.t += dt * speed;
            if (tr.t >= 1) {
                // Move to next edge in flow
                const flow = voroxFlowCache;
                const centers = voroxCenters;
                const nextFacet = flow.activeEdges[tr.curTet][tr.curFace];
                if (!nextFacet) {
                    tr.t = 0; return; // stall
                }
                const nextNext = flow.activeEdges[nextFacet.tet][nextFacet.face];
                tr.curTet = nextFacet.tet;
                tr.curFace = nextFacet.face;
                tr.start = new THREE.Vector3(...centers[tr.curTet]);
                const nextTet = (nextNext && nextNext.tet) || tr.curTet;
                tr.end = new THREE.Vector3(...centers[nextTet]);
                tr.dir = new THREE.Vector3().subVectors(tr.end, tr.start);
                tr.t = 0;
            }
            const pos = new THREE.Vector3().copy(tr.start).addScaledVector(tr.dir, tr.t);
            tr.mesh.position.copy(pos);
        }

        function updateVoroxTracers() {
            if (!document.getElementById('animateVoroXFlow').checked) return;
            if (!voroxTracers.length || !voroxFlowCache || !voroxCenters) return;
            const now = performance.now();
            const dt = Math.min(0.05, (now - lastFrameTime) / 1000);
            lastFrameTime = now;
            for (const tr of voroxTracers) stepTracer(tr, dt);
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(module => {
            Module = module;
            setStatus('Module loaded', true);
            
            initThree();
            // Panel hide/show
            document.getElementById('controls-toggle').addEventListener('click', () => {
                const panel = document.getElementById('controls');
                const btn = document.getElementById('controls-toggle');
                if (panel.classList.contains('hidden')) {
                    panel.classList.remove('hidden');
                    btn.textContent = 'hide';
                    btn.title = 'Hide Controls';
                } else {
                    panel.classList.add('hidden');
                    btn.textContent = 'show';
                    btn.title = 'Show Controls';
                }
            });

            // Background color control
            document.getElementById('backgroundColor').addEventListener('change', (e) => {
                scene.background = new THREE.Color(e.target.value);
            });
            
            // Generate initial points
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            const usePoisson = document.getElementById('poissonSampling').checked;
            const points = usePoisson ? 
                generatePoissonPoints(numPoints, minDist) : 
                generateWellDistributedPoints(numPoints, minDist);
            currentPoints = points;
            
            computeDelaunayVoronoi();
            
            // Set up event listeners
            document.getElementById('showVertices').addEventListener('change', (e) => {
                verticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showDelaunay').addEventListener('change', (e) => {
                delaunayGroup.visible = e.target.checked;
            });
            
            const voronoiEdgesToggle = document.getElementById('showVoronoiEdgesToggle');
            if (voronoiEdgesToggle) {
                voronoiEdgesToggle.addEventListener('change', (e) => {
                    voronoiGroup.visible = e.target.checked;
                });
            }
            
            document.getElementById('showTetrahedra').addEventListener('change', (e) => {
                tetrahedraGroup.visible = e.target.checked;
            });
            
            document.getElementById('showBoundary').addEventListener('change', (e) => {
                boundaryGroup.visible = e.target.checked;
                const axes = scene.getObjectByName('axesHelper');
                if (axes) axes.visible = e.target.checked;
            });

            document.getElementById('voronoiFaceColor').addEventListener('change', () => {
                drawVoronoiFaces(computation);
            });
            
            document.getElementById('voronoiFaceOpacity').addEventListener('change', () => {
                drawVoronoiFaces(computation);
            });
            
            document.getElementById('showVoronoiFaces').addEventListener('change', () => {
                drawVoronoiFaces(computation);
            });
            
            document.getElementById('regenerate').addEventListener('click', () => {
                const numPoints = parseInt(document.getElementById('numPoints').value);
                const minDist = parseFloat(document.getElementById('minDistance').value);
                const usePoisson = document.getElementById('poissonSampling').checked;
                const points = usePoisson ? 
                    generatePoissonPoints(numPoints, minDist) : 
                    generateWellDistributedPoints(numPoints, minDist);
                currentPoints = points;
                computeDelaunayVoronoi();
            });
            
            document.getElementById('recompute').addEventListener('click', () => {
                computeDelaunayVoronoi();
            });
            
            document.getElementById('periodicMode').addEventListener('change', () => {
                computeDelaunayVoronoi();
            });
            document.getElementById('showVoroX').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('voroxColorByKnot').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('voroxMaxSegs').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('showVoroXKnots').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('voroxKnotWidth').addEventListener('change', () => drawMeshes(computation));
            
            // Size and color controls
            document.getElementById('delaunaySize').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('vertexColor').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('delaunayEdgeColor').addEventListener('change', () => { drawMeshes(computation); createGhostCellTiling(); });
            document.getElementById('useMIC').addEventListener('change', (e) => {
                document.getElementById('delaunayEdgeWidth').disabled = !e.target.checked;
                document.getElementById('voronoiEdgeWidth').disabled = !e.target.checked;
                drawMeshes(computation);
            });
            document.getElementById('delaunayEdgeWidth').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('voronoiEdgeWidth').addEventListener('change', () => drawMeshes(computation));
            document.getElementById('showGhostCells').addEventListener('change', () => {
                createGhostCellTiling();
            });
            
            document.getElementById('voronoiSize').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('voronoiVertexColor').addEventListener('change', () => {
                drawMeshes(computation);
            });

            document.getElementById('voronoiEdgeColor').addEventListener('change', () => { drawMeshes(computation); createGhostCellTiling(); });
            
            document.getElementById('tetraColor').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            document.getElementById('tetraOpacity').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            animate();
            
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 