<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 380px;
        }
        #controls-content { max-height: calc(100vh - 40px); overflow-y: auto; }
        .control-group {
            margin: 10px 0;
        }
        .section-header { font-weight: bold; margin: 12px 0 6px 0; padding: 6px 8px; background: #f2f2f2; border-radius: 4px; }
        #controls-toggle { background: #007bff; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-bottom: 8px; }
        #controls.hidden { width: auto; padding: 8px 10px; }
        #controls.hidden #controls-content { display: none; }
        .row-2 { display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; align-items: center; }
        .row-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; align-items: center; }
        .row-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; align-items: center; }
        .sub-label { font-size: 12px; text-align: center; opacity: 0.85; }
        .inline-pair { display: flex; align-items: center; gap: 8px; }
        .inline-tight { gap: 4px; }
        label {
            display: inline-block;
            width: 100px;
            font-size: 14px;
            white-space: nowrap;
        }
        input[type="number"] {
            width: 80px;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
        <div class="section-header">Voro-X / Geogram</div>
        <div class="control-group row-2">
            <div class="inline-pair"><label>Points:</label><input type="number" id="numPoints" value="150" min="4" max="5000"></div>
            <div class="inline-pair inline-tight"><label>Min Dist:</label><input style="margin-left:-6px" type="number" id="minDistance" value="0.05" min="0.001" max="0.3" step="0.001"></div>
        </div>
        <div class="control-group row-2">
             <button id="regenerate">Generate</button>
             <button id="recompute">Recompute</button>
        </div>
        <div class="control-group">
            <label>Voronoi Method:</label>
            <select id="voronoiMethod">
                <option value="barycenter" selected>Barycenter</option>
                <option value="circumcenter">Circumcenter</option>
            </select>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Periodic</div>
            <div class="sub-label">Ghost Cells</div>
            <div class="sub-label">MIC</div>
            <div style="text-align:center"><input type="checkbox" id="periodicMode"></div>
            <div style="text-align:center"><input type="checkbox" id="showGhostCells"></div>
            <div style="text-align:center"><input type="checkbox" id="useMIC"></div>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Background</div>
            <div class="sub-label">Boundary</div>
            <div class="sub-label">Poisson</div>
            <div style="text-align:center"><input type="color" id="backgroundColor" value="#f0f0f0"></div>
            <div style="text-align:center"><input type="checkbox" id="showBoundary" checked></div>
            <div style="text-align:center"><input type="checkbox" id="poissonSampling" checked></div>
        </div>
        <hr>
        <div class="section-header">Flow Dynamics</div>
        <div class="control-group">
            <div class="row-3">
                <button id="resampleBtn">Resample</button>
                <button id="stepBtn">Step</button>
                <button id="liveBtn">Live</button>
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>dt</label>
                <input type="text" id="dynDt" value="0,02">
            </div>
            <div>
                <label>Energy</label>
                <input type="text" id="dynEnergy" value="0,0005">
            </div>
        </div>
        <div class="control-group row-3">
            <div>
                <label>Scale</label>
                <input type="text" id="dynScale" value="0,5">
            </div>
            <div class="inline-pair"><input type="checkbox" id="dynEdgeScale" checked><label>Edge Scale</label></div>
            <div class="inline-pair"><input type="checkbox" id="dynEquilibration" checked><label>Equilibration</label></div>
        </div>
        <div class="control-group row-2">
            <div class="inline-pair"><input type="checkbox" id="dynContractive"><label>Contractive</label></div>
            <div class="inline-pair"><input type="checkbox" id="dynExpansive"><label>Expansive</label></div>
        </div>
        <div class="control-group row-2">
            <div class="inline-pair"><input type="checkbox" id="showVoroX" checked><label>Flow</label></div>
            <div class="inline-pair"><label>Max Segs:</label><input type="number" id="voroxMaxSegs" value="2000" min="100" max="20000" step="100"></div>
        </div>
        <div class="control-group row-3">
            <div class="inline-pair"><input type="checkbox" id="showVoroXKnots" checked><label>Knots</label></div>
            <div class="inline-pair"><input type="checkbox" id="showGhostCells"><label>Ghost Cells</label></div>
            <div class="inline-pair"><input type="checkbox" id="voroxColorByKnot" checked><label for="voroxColorByKnot">Color by Knot</label></div>
        </div>
        <hr>
        <div class="section-header">Delaunay Triangles / Tetrahedra</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Delaunay</div>
            <div class="sub-label">Tetrahedra</div>
            <div style="text-align:center"><input type="checkbox" id="showVertices" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showDelaunay" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showTetrahedra" checked></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="delaunaySize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="vertexColor" value="#000000">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="10" step="1" disabled>
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="delaunayEdgeColor" value="#808080">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Tetra Color:</label>
                <input type="color" id="tetraColor" value="#D3D3D3">
            </div>
            <div>
                <label>Opacity:</label>
                <input type="number" id="tetraOpacity" value="0.01" min="0.0" max="1.0" step="0.01">
            </div>
        </div>
        <hr>
        <div class="section-header">Voronoi Diagrams</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Edges</div>
            <div class="sub-label">Faces</div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoi"></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiEdgesToggle"></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiFaces"></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="voronoiSize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="voronoiVertexColor" value="#0000FF">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="voronoiEdgeWidth" value="2" min="1" max="10" step="1" disabled>
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="voronoiEdgeColor" value="#4169E1">
            </div>
        </div>
        <!-- Move Tetra controls to Delaunay section and place Voronoi Method later -->
        <div class="control-group">
            <div class="row-2">
                <div>
                    <label>Faces Color:</label>
                    <input type="color" id="voronoiFaceColor" value="#ADD8E6">
                </div>
                <div>
                    <label>Opacity:</label>
                    <input type="number" id="voronoiFaceOpacity" value="0.04" min="0.0" max="1.0" step="0.01">
                </div>
            </div>
        </div>
        
        <hr>
        <div id="status" class="status"></div>
        <div id="stats" style="font-size:12px; margin-top:8px">
            <span id="statsCore">Loading...</span><br>
            <span id="statsPerf"></span>
        </div>
        </div>
    </div>
    
    <script src="../../dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { DelaunayComputation } from '../../src/js/DelaunayComputation.js';
        import { createVoroX } from '../../src/js/VoroXAdapter.js';
        import { barycenter } from '../../src/js/vorox2/core.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiGroup, voronoiFacesGroup, tetrahedraGroup, voroxGroup, boundaryGroup, ghostCellsGroup;
        let Module;
        let currentPoints = [];
        let voroxInstance = null;
        let live = false;
        let rafId = 0;
        let lastFrameTime = performance.now();
        let lastFPSUpdate = performance.now();

        function setStatus(message, isSuccess = true) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Initialize Three.js
        function initThree() {
            if (renderer) return; // prevent multiple WebGL context creations
            scene = new THREE.Scene();
            const bgHex = document.getElementById('backgroundColor').value || '#c2c2c2';
            scene.background = new THREE.Color(bgHex);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Hide/Show controls toggle
            const toggleBtn = document.getElementById('controls-toggle');
            const controlsPanel = document.getElementById('controls');
            toggleBtn.addEventListener('click', () => {
                controlsPanel.classList.toggle('hidden');
                toggleBtn.textContent = controlsPanel.classList.contains('hidden') ? 'show' : 'hide';
            });
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            voroxGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            
            scene.add(verticesGroup);
            scene.add(delaunayGroup);
            scene.add(voronoiGroup);
            scene.add(voronoiFacesGroup);
            scene.add(tetrahedraGroup);
            scene.add(voroxGroup);
            scene.add(boundaryGroup);
            scene.add(ghostCellsGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers (toggle with boundary)
            const axesHelper = new THREE.AxesHelper(0.2);
            axesHelper.name = 'axesHelper';
            scene.add(axesHelper);
            
            // Ghost cell tiling drawn by drawGhostCells when enabled
        }

        // Ghost cells tiling (26 neighbors) using boundary boxes for now
        function createGhostCellTiling() {
            // Cleanup
            ghostCellsGroup.clear();
            if (!document.getElementById('showGhostCells').checked || !voroxInstance || !voroxInstance.getFoam().isPeriodic) return;

            const foam = voroxInstance.getFoam();
            const delaunayVisible = document.getElementById('showDelaunay').checked;
            const voronoiVisible = document.getElementById('showVoronoiEdgesToggle').checked;

            if (!delaunayVisible && !voronoiVisible) return;

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const ghostDelaunayMat = new THREE.LineBasicMaterial({ color: delaunayEdgeColorHex, opacity: 0.2, transparent: true });
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const ghostVoronoiMat = new THREE.LineBasicMaterial({ color: voronoiEdgeColorHex, opacity: 0.15, transparent: true });

            // Build base geometries once
            const buildDelaunayGeom = () => {
                const positions = [];
                const edgeSet = new Set();
                for (const tet of foam.simplices) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a, b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (edgeSet.has(key)) continue; edgeSet.add(key);
                        const p1 = foam.points[a];
                        const p2 = getMinimumImage(p1, foam.points[b]);
                        positions.push(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
                    }
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };
            const buildVoronoiGeom = () => {
                const positions = [];
                const vizCenters = foam.simplices.map(tet => barycenter(foam.points, tet, foam.isPeriodic));
                const done = new Set();
                for (let ti=0; ti<foam.facetPairs.length; ti++) {
                    for (let fi=0; fi<4; fi++) {
                        const m = foam.facetPairs[ti][fi];
                        if (!m) continue;
                        const a=ti, b=m.tet;
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (done.has(key)) continue; done.add(key);
                        const c1 = vizCenters[a];
                        const c2raw = vizCenters[b];
                        const c2 = getMinimumImage(c1, c2raw);
                        positions.push(c1[0], c1[1], c1[2], c2[0], c2[1], c2[2]);
                    }
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };

            const delaunayGeom = delaunayVisible ? buildDelaunayGeom() : null;
            const voronoiGeom = voronoiVisible ? buildVoronoiGeom() : null;

            const offsets = [];
            for (let x=-1; x<=1; x++) for (let y=-1; y<=1; y++) for (let z=-1; z<=1; z++) {
                if (x===0 && y===0 && z===0) continue;
                offsets.push([x,y,z]);
            }

            for (const [ox, oy, oz] of offsets) {
                const g = new THREE.Group();
                g.position.set(ox, oy, oz);
                if (delaunayGeom) g.add(new THREE.LineSegments(delaunayGeom, ghostDelaunayMat));
                if (voronoiGeom) g.add(new THREE.LineSegments(voronoiGeom, ghostVoronoiMat));
                ghostCellsGroup.add(g);
            }
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }
        
        // Visualize vertices
        function drawVertices(points) {
            verticesGroup.clear();
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const material = new THREE.MeshPhongMaterial({ color: vertexColorHex });
            const geometry = new THREE.SphereGeometry(vertexSize, 12, 12);
            for (const p of points) {
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(p[0], p[1], p[2]);
                verticesGroup.add(sphere);
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(foam) {
            delaunayGroup.clear();
            if (!document.getElementById('showDelaunay').checked) { delaunayGroup.visible = false; return; }
            delaunayGroup.visible = true;
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const material = new THREE.LineBasicMaterial({ color: delaunayEdgeColorHex });
            const positions = [];
            const edgeSet = new Set();
            for (const tet of foam.simplices) {
                const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (edgeSet.has(key)) continue;
                        edgeSet.add(key);
                    const p1 = foam.points[a];
                    const useMIC = document.getElementById('useMIC').checked;
                    const p2 = (foam.isPeriodic && useMIC) ? getMinimumImage(p1, foam.points[b]) : foam.points[b];
                    positions.push(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
                }
            }
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            delaunayGroup.add(new THREE.LineSegments(geom, material));
        }

        function parseNumInput(elId, fallback) {
            const v = (document.getElementById(elId).value || '').toString().replace(',', '.');
            const n = parseFloat(v);
            return Number.isFinite(n) ? n : fallback;
        }

        // Draw Voronoi vertices/edges and VoroX flow using foam structure
        function drawVoronoiAndFlow(foam) {
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();
            if (!foam) return;

            const showVoronoiVerts = document.getElementById('showVoronoi').checked;
            const showVoronoiEdges = document.getElementById('showVoronoiEdgesToggle').checked;
            const showVoronoiFaces = document.getElementById('showVoronoiFaces').checked;
            const showFlow = document.getElementById('showVoroX').checked;
            voronoiGroup.visible = showVoronoiVerts || showVoronoiEdges;
            voronoiFacesGroup.visible = showVoronoiFaces;
            voroxGroup.visible = showFlow;

            // Precompute visualization centers (barycenters ensure containment)
            const vizCenters = foam.simplices.map(tet => barycenter(foam.points, tet, foam.isPeriodic));

            // Voronoi vertices as spheres
            if (showVoronoiVerts) {
                const size = parseFloat(document.getElementById('voronoiSize').value);
                const colorHex = document.getElementById('voronoiVertexColor').value;
                const colorInt = parseInt(colorHex.substring(1), 16);
                const sphereGeom = new THREE.SphereGeometry(size, 8, 8);
                const sphereMat = new THREE.MeshPhongMaterial({ color: colorInt, emissive: colorInt, emissiveIntensity: 0.3 });
                for (const c of vizCenters) {
                    const s = new THREE.Mesh(sphereGeom, sphereMat);
                    s.position.set(c[0], c[1], c[2]);
                    voronoiGroup.add(s);
                }
            }

            // Voronoi edges from facetPairs
            if (showVoronoiEdges) {
                const edgeColorHex = document.getElementById('voronoiEdgeColor').value;
                const mat = new THREE.LineBasicMaterial({ color: edgeColorHex });
                const matPeriodic = new THREE.LineBasicMaterial({ color: edgeColorHex, opacity: 0.8, transparent: true });
                const done = new Set();
                const useMIC = document.getElementById('useMIC').checked;
                for (let ti = 0; ti < foam.facetPairs.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        const m = foam.facetPairs[ti][fi];
                        if (!m) continue;
                        const a = ti, b = m.tet;
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (done.has(key)) continue;
                        done.add(key);
                        const c1 = vizCenters[a];
                        const c2raw = vizCenters[b];
                        const c2 = (foam.isPeriodic && useMIC) ? getMinimumImage(c1, c2raw) : c2raw;
                        const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(...c1), new THREE.Vector3(...c2)]);
                        voronoiGroup.add(new THREE.Line(g, foam.isPeriodic ? matPeriodic : mat));
                    }
                }
            }

            // Voronoi faces via convex hull of centers per original vertex
            if (showVoronoiFaces) {
                const faceColorHex = document.getElementById('voronoiFaceColor').value;
                const faceColorInt = parseInt(faceColorHex.substring(1), 16);
                const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
                const material = new THREE.MeshPhongMaterial({ color: faceColorInt, opacity, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                const cells = new Map();
                for (let ti=0; ti<foam.simplices.length; ti++) {
                    const center = vizCenters[ti]; if (!center) continue;
                    const tet = foam.simplices[ti];
                    for (const v of tet) {
                        if (!cells.has(v)) cells.set(v, []);
                        cells.get(v).push(new THREE.Vector3(...center));
                    }
                }
                cells.forEach((verts) => {
                    if (verts.length < 4) return;
                    // MIC adjust to first vertex if periodic
                    const useMIC = document.getElementById('useMIC').checked;
                    const ref = verts[0];
                    const adjusted = verts.map(p => {
                        const out = p.clone();
                        if (!(foam.isPeriodic && useMIC)) return out;
                        for (let k=0;k<3;k++) {
                            let diff = p.getComponent(k) - ref.getComponent(k);
                            if (diff > 0.5) out.setComponent(k, p.getComponent(k) - 1.0);
                            else if (diff < -0.5) out.setComponent(k, p.getComponent(k) + 1.0);
                        }
                        return out;
                    });
                    const geom = new ConvexGeometry(adjusted);
                    voronoiFacesGroup.add(new THREE.Mesh(geom, material));
                });
            }

            // VoroX flow using activeEdges
            if (showFlow) {
                const colorByKnot = document.getElementById('voroxColorByKnot').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                // Determine a simple strength metric using knotDist as proxy for flow amount
                let maxStrength = 1;
                for (let ti=0; ti<foam.knotDist.length; ti++) {
                    for (let fi=0; fi<4; fi++) {
                        if (!foam.activeEdges[ti][fi]) continue;
                        maxStrength = Math.max(maxStrength, (foam.knotDist[ti][fi] || 1));
                    }
                }
                function strengthToColor(s) {
                    const t = Math.max(0, Math.min(1, (s-1)/(maxStrength-1 || 1)));
                    // blue->green->red via HSL
                    const c = new THREE.Color();
                    c.setHSL(0.67*(1-t), 0.9, 0.5);
                    return c;
                }
                const useMIC = document.getElementById('useMIC').checked;
                let drawn = 0;
                for (let ti = 0; ti < foam.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = foam.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = vizCenters[ti];
                        let c2 = vizCenters[nxt.tet];
                        if (foam.isPeriodic && useMIC) c2 = getMinimumImage(c1, c2);
                        const knotId = foam.facetKnot && foam.facetKnot[ti] ? foam.facetKnot[ti][fi] : 0;
                        const strength = foam.knotDist && foam.knotDist[ti] ? (foam.knotDist[ti][fi] || 1) : 1;
                        const col = colorByKnot && knotId > 0 ? new THREE.Color().setHSL((knotId * 0.1375) % 1, 0.85, 0.5) : strengthToColor(strength);
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.95, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...c1), new THREE.Vector3(...c2) ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Optional: emphasize knots if requested
                if (document.getElementById('showVoroXKnots').checked && foam.knots && foam.knots.length) {
                    for (const knot of foam.knots) {
                        for (let i = 0; i < knot.length; i++) {
                            const a = knot[i];
                            const b = foam.activeEdges[a.tet][a.face];
                            if (!b) continue;
                            let c1 = vizCenters[a.tet];
                            let c2 = vizCenters[b.tet];
                            const useMIC = document.getElementById('useMIC').checked;
                            if (foam.isPeriodic && useMIC) c2 = getMinimumImage(c1, c2);
                            const mat = new THREE.LineBasicMaterial({ color: 0x000000 });
                            const g = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...c1), new THREE.Vector3(...c2) ]);
                            voroxGroup.add(new THREE.Line(g, mat));
                        }
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            const voronoiColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiColorInt = parseInt(voronoiColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt,
                linewidth: 2 
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt, 
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiColorInt,
                emissive: voronoiColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.clear();
            
            // Support faces for both barycenter and circumcenter methods; limit point count for perf
            const maxPointsForFaces = 300;
            const showFaces = document.getElementById('showVoronoiFaces').checked;
            voronoiFacesGroup.visible = showFaces;
            if (!showFaces) return;
            if (computation.numPoints > maxPointsForFaces) {
                console.log(`Skipping faces: points=${computation.numPoints} > ${maxPointsForFaces}`);
                return;
            }
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the centers (barycenters==circumcenters in this mode)
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const center = computation.barycenters[index];
                if (!center) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...center));
                });
            });

            // For each cell, compute the convex hull of its vertices (centers)
            let built = 0;
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return; // Need at least 4 points for a 3D shape

                // Create a convex geometry from the vertices of the Voronoi cell
                // Apply MIC to bring all vertices to the same periodic image as the first vertex
                const ref = cellVertices[0];
                const adjusted = cellVertices.map(v => {
                    const out = v.clone();
                    if (!computation.isPeriodic) return out;
                    for (let k = 0; k < 3; k++) {
                        let diff = v.getComponent(k) - ref.getComponent(k);
                        if (diff > 0.5) out.setComponent(k, v.getComponent(k) - 1.0);
                        else if (diff < -0.5) out.setComponent(k, v.getComponent(k) + 1.0);
                    }
                    return out;
                });

                const geometry = new ConvexGeometry(adjusted);
                const mesh = new THREE.Mesh(geometry, material);
                voronoiFacesGroup.add(mesh);
                built++;
            });
            console.log(`Built ${built} Voronoi cell meshes`);
        }
        
        // Unified mesh drawing function that properly handles periodic edges
        function drawMeshes(computation) {
            delaunayGroup.clear();
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();

            console.log(`Drawing meshes for ${computation.isPeriodic ? 'PERIODIC' : 'NON-PERIODIC'} mode`);

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt, linewidth: 2, opacity: 0.6, transparent: true });

            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges ---
            const useMIC = document.getElementById('useMIC').checked;
            const delaunayEdgeSet = new Set();
            const thickDelaunayWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
            const thickVoronoiWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
            if (useMIC) {
                // Thick edges using MIC
                const delaunayGeom = new LineGeometry();
                const delaunayPositions = [];
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        delaunayPositions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                    }
                }
                delaunayGeom.setPositions(delaunayPositions);
                const delaunayMat = new LineMaterial({ color: delaunayEdgeColorInt, linewidth: thickDelaunayWidth, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
                const delaunayLine = new Line2(delaunayGeom, delaunayMat);
                delaunayLine.computeLineDistances();
                delaunayGroup.add(delaunayLine);
            } else {
                // Thin edges (existing path with MIC per-edge)
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                        delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                    }
                }
            }

            console.log(`Drew ${periodicEdgeCount} periodic edges out of ${delaunayEdgeSet.size} total Delaunay edges`);
            
            // --- Draw Voronoi Edges ---
            if (useMIC) {
                const vorGeom = new LineGeometry();
                const positions = [];
                for (const edge of computation.voronoiEdges) {
                    const p1 = edge.start;
                    const p2 = computation.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                    positions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                }
                vorGeom.setPositions(positions);
                const vorMat = new LineMaterial({ color: voronoiEdgeColorInt, linewidth: thickVoronoiWidth, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
                const vorLine = new Line2(vorGeom, vorMat);
                vorLine.computeLineDistances();
                voronoiGroup.add(vorLine);
            } else {
                for (const edge of computation.voronoiEdges) {
                    const p1 = edge.start;
                    const p2 = computation.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                    voronoiGroup.add(new THREE.Line(lineGeom, computation.isPeriodic ? voronoiPeriodicMaterial : voronoiMaterial));
                }
            }
            
            // Draw Voronoi vertices (barycenters or circumcenters)
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }

            // Draw VoroX flow if enabled
            if (document.getElementById('showVoroX').checked) {
                const centers = computation.barycenters;
                const faceAdj = computation.getFaceAdjacency();
                const flow = buildVoroXFlow({ tetrahedra: computation.tetrahedra, centers, faceAdjacency: faceAdj });
                const colorByKnot = document.getElementById('voroxColorByKnot').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                voroxFlowCache = flow;
                voroxCenters = centers;

                let drawn = 0;
                for (let ti = 0; ti < flow.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = flow.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = centers[ti];
                        let c2 = centers[nxt.tet];
                        if (computation.isPeriodic) {
                            c2 = getMinimumImage(c1, c2);
                        }
                        const col = colorByKnot && flow.facetToKnot[ti][fi] > 0
                            ? new THREE.Color().setHSL((flow.facetToKnot[ti][fi] * 0.1375) % 1, 0.85, 0.5)
                            : new THREE.Color(0xff00aa);
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.9, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                        ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Highlight knots (cycles) if enabled
                if (document.getElementById('showVoroXKnots').checked && flow.knots.length) {
                    const baseWidth = parseFloat(document.getElementById('voroxKnotWidth').value);
                    for (const knot of flow.knots) {
                        for (let i = 0; i < knot.length; i++) {
                            const a = knot[i];
                            const b = flow.activeEdges[a.tet][a.face];
                            if (!b) continue;
                            let c1 = centers[a.tet];
                            let c2 = centers[b.tet];
                            if (computation.isPeriodic) {
                                c2 = getMinimumImage(c1, c2);
                            }
                            const mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: baseWidth, opacity: 1.0 });
                            const g = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                            ]);
                            voroxGroup.add(new THREE.Line(g, mat));
                        }
                    }
                }
                // Initialize tracers if animation is on
                if (document.getElementById('animateVoroXFlow').checked) {
                    initVoroxTracers(flow, centers);
                } else {
                    clearVoroxTracers();
                }
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                const vertices = tet.map(i => computation.pointsArray[i]);
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // --- VoroX v2 Drawing Functions ---
        function drawVoroX2(foam) {
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();

            console.log(`Drawing VoroX2 for ${foam.simplices.length} tets, ${foam.knots.length} knots`);

            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);

            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            const voronoiFaceMaterial = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: parseFloat(document.getElementById('voronoiFaceOpacity').value),
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Draw Voronoi vertices (barycenters or circumcenters)
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of foam.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }

            // Draw Voronoi edges
            for (const edge of foam.voronoiEdges) {
                const p1 = edge.start;
                const p2 = foam.isPeriodic ? getMinimumImage(p1, edge.end) : edge.end;
                const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                voronoiGroup.add(new THREE.Line(lineGeom, foam.isPeriodic ? voronoiPeriodicMaterial : voronoiMaterial));
            }

            // Draw Voronoi faces
            const maxPointsForFaces = 300;
            const showFaces = document.getElementById('showVoronoiFaces').checked;
            voronoiFacesGroup.visible = showFaces;
            if (!showFaces) return;
            if (foam.numPoints > maxPointsForFaces) {
                console.log(`Skipping faces: points=${foam.numPoints} > ${maxPointsForFaces}`);
                return;
            }
            if (!foam.tetrahedra.length || !foam.barycenters.length) return;

            const cells = new Map();
            foam.tetrahedra.forEach((tet, index) => {
                const center = foam.barycenters[index];
                if (!center) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...center));
                });
            });

            let built = 0;
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return;

                const ref = cellVertices[0];
                const adjusted = cellVertices.map(v => {
                    const out = v.clone();
                    if (!foam.isPeriodic) return out;
                    for (let k = 0; k < 3; k++) {
                        let diff = v.getComponent(k) - ref.getComponent(k);
                        if (diff > 0.5) out.setComponent(k, v.getComponent(k) - 1.0);
                        else if (diff < -0.5) out.setComponent(k, v.getComponent(k) + 1.0);
                    }
                    return out;
                });

                const geometry = new ConvexGeometry(adjusted);
                const mesh = new THREE.Mesh(geometry, voronoiFaceMaterial);
                voronoiFacesGroup.add(mesh);
                built++;
            });
            console.log(`Built ${built} Voronoi cell meshes`);

            // Draw VoroX flow if enabled
            if (document.getElementById('showVoroX').checked) {
                const centers = foam.barycenters;
                const faceAdj = foam.getFaceAdjacency();
                const flow = buildVoroXFlow({ tetrahedra: foam.tetrahedra, centers, faceAdjacency: faceAdj });
                const colorByKnot = document.getElementById('voroxColorByKnot').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                voroxFlowCache = flow;
                voroxCenters = centers;

                let drawn = 0;
                for (let ti = 0; ti < flow.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = flow.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = centers[ti];
                        let c2 = centers[nxt.tet];
                        if (foam.isPeriodic) {
                            c2 = getMinimumImage(c1, c2);
                        }
                        const col = colorByKnot && flow.facetToKnot[ti][fi] > 0
                            ? new THREE.Color().setHSL((flow.facetToKnot[ti][fi] * 0.1375) % 1, 0.85, 0.5)
                            : new THREE.Color(0xff00aa);
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.9, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                        ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Highlight knots (cycles) if enabled
                if (document.getElementById('showVoroXKnots').checked && flow.knots.length) {
                    const baseWidth = parseFloat(document.getElementById('voroxKnotWidth').value);
                    for (const knot of flow.knots) {
                        for (let i = 0; i < knot.length; i++) {
                            const a = knot[i];
                            const b = flow.activeEdges[a.tet][a.face];
                            if (!b) continue;
                            let c1 = centers[a.tet];
                            let c2 = centers[b.tet];
                            if (foam.isPeriodic) {
                                c2 = getMinimumImage(c1, c2);
                            }
                            const mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: baseWidth, opacity: 1.0 });
                            const g = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                            ]);
                            voroxGroup.add(new THREE.Line(g, mat));
                        }
                    }
                }
                // Initialize tracers if animation is on
                if (document.getElementById('animateVoroXFlow').checked) {
                    initVoroxTracers(flow, centers);
                } else {
            clearVoroxTracers();
                }
            }
        }

        // --- VoroX v2 Main Logic ---
        async function recompute() {
            if (!Module) return;
            const periodic = document.getElementById('periodicMode').checked;
            const centering = document.getElementById('voronoiMethod').value || 'circumcenter';
            voroxInstance = await createVoroX({ Module, points: currentPoints, periodic, centering });
            updateScene();
        }

        function updateScene() {
            if (!voroxInstance) return;
            const foam = voroxInstance.getFoam();
            // Background color
            const bgHex = document.getElementById('backgroundColor').value;
            if (bgHex) scene.background = new THREE.Color(bgHex);
            // Boundary toggle
            const showBoundary = document.getElementById('showBoundary').checked;
            boundaryGroup.visible = showBoundary;
            const axes = scene.getObjectByName('axesHelper'); if (axes) axes.visible = showBoundary;
            // Vertices
            verticesGroup.clear();
            if (document.getElementById('showVertices').checked) {
                drawVertices(foam.points);
                verticesGroup.visible = true;
            } else { verticesGroup.visible = false; }
            drawDelaunay(foam);
            drawVoronoiAndFlow(foam);
            createGhostCellTiling();
            const statsCore = document.getElementById('statsCore');
            if (statsCore) {
                statsCore.textContent = `VoroX2: ${foam.simplices.length} tets, ${foam.knots.length} knots, periodic:${foam.isPeriodic}`;
            }
        }
        
        function step() {
            if (!voroxInstance) return;
            const dt = parseNumInput('dynDt', 0.02);
            const energy = parseNumInput('dynEnergy', 5e-4);
            const scale = parseNumInput('dynScale', 0.5);
            const opts = {
                edgeScale: document.getElementById('dynEdgeScale').checked,
                scale,
                energy,
                equilibration: document.getElementById('dynEquilibration').checked,
                contractive: document.getElementById('dynContractive').checked,
                expansive: document.getElementById('dynExpansive').checked,
                recomputeEvery: 5,
            };
            voroxInstance.step(dt, opts);
            updateScene();
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(async module => {
            Module = module;
            setStatus('Module loaded');
            
            initThree();
            
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            currentPoints = generatePoissonPoints(numPoints, minDist);
            
            await recompute();
            
            document.getElementById('regenerate').addEventListener('click', async () => {
                const numPoints = parseInt(document.getElementById('numPoints').value);
                const minDist = parseFloat(document.getElementById('minDistance').value);
                currentPoints = generatePoissonPoints(numPoints, minDist);
                await recompute();
            });

            const recomputeBtn = document.getElementById('recompute');
            if (recomputeBtn) {
                recomputeBtn.addEventListener('click', async () => {
                    await recompute();
                });
            }
            // Voronoi method change triggers rebuild
            const methodSel = document.getElementById('voronoiMethod');
            methodSel.addEventListener('change', async () => { await recompute(); });

            // Test-style controls wiring
            document.getElementById('resampleBtn').addEventListener('click', async () => {
                const N = parseInt(document.getElementById('numPoints').value) || 200;
                const minDist = parseFloat(document.getElementById('minDistance').value) || 0.05;
                currentPoints = generatePoissonPoints(N, minDist);
                await recompute();
            });
            document.getElementById('stepBtn').addEventListener('click', () => step());
            const liveBtn = document.getElementById('liveBtn');
            let liveOn = false;
            function liveLoop() {
                if (!liveOn) return;
                step();
                rafId = requestAnimationFrame(liveLoop);
            }
            liveBtn.addEventListener('click', () => {
                liveOn = !liveOn;
                liveBtn.style.backgroundColor = liveOn ? '#28a745' : '';
                if (liveOn) liveLoop(); else cancelAnimationFrame(rafId);
            });

            document.getElementById('periodicMode').addEventListener('change', async () => {
                if (voroxInstance) {
                    voroxInstance.setPeriodic(document.getElementById('periodicMode').checked);
                    // sync Flow-periodic checkbox if present
                    const dp = document.getElementById('dynPeriodic'); if (dp) dp.checked = document.getElementById('periodicMode').checked;
                    updateScene();
                }
            });
            // Flow dynamics Periodic toggle (syncs with top)
            const dynPeriodic = document.createElement('input');
            dynPeriodic.type = 'checkbox';
            dynPeriodic.id = 'dynPeriodic';
            dynPeriodic.style.display = 'none'; // logical control only
            document.body.appendChild(dynPeriodic);
            dynPeriodic.addEventListener('change', async () => {
                const val = dynPeriodic.checked;
                const top = document.getElementById('periodicMode');
                top.checked = val;
                if (voroxInstance) {
                    voroxInstance.setPeriodic(val);
                    updateScene();
                }
            });

            // Animation is handled by the Live button only
 
            // Re-render on toggles that affect visibility/coloring
            const rerenderIds = [
                'showVertices','showDelaunay','showTetrahedra','showVoronoi','showVoronoiEdgesToggle','showVoronoiFaces',
                'showVoroX','showVoroXKnots','voroxColorByKnot','voroxMaxSegs','voronoiSize','voronoiVertexColor','showGhostCells',
                'voronoiEdgeColor','delaunayEdgeColor','tetraOpacity','tetraColor','backgroundColor','useMIC','showBoundary'
            ];
            rerenderIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', () => updateScene());
            });

            function animate() {
                const now = performance.now();
                const delta = now - lastFrameTime;
                lastFrameTime = now;

                if (now - lastFPSUpdate > 500) { // Update FPS twice a second
                    const fps = 1000 / delta;
                    const statsPerf = document.getElementById('statsPerf');
                    if (statsPerf) statsPerf.textContent = `FPS: ${fps.toFixed(1)}`;
                    lastFPSUpdate = now;
                }

                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 